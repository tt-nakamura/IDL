// uses NTL
//   http://www.shoup.net/ntl
// reference:
//   H. Cohen, "A Course in Computational Algebraic Number theory"

#include "IDL_p.h"

Mat<vec_zz_p> IDL_p::M;// multiplication table

// assume zz_p and IDL have been initialized
void IDL_p::init() { conv(M, IDL::M); }

void conv(IDL2& x, const ZZ_pX& f)
// x = two element representation of ideal generated by (p,f)
{
    long i,n(IDL::degree());
    ZZX g;
    conv(g,f);
    g %= IDL::T;
    VectorCopy(x, g.rep, n);
    x *= IDL::W1;
    for(i=0; i<n; i++) x[i] /= IDL::d1;
    x.a = ZZ_p::modulus();
    power(x.N, x.a, deg(f));;
}

void conv(IDL2& x, const IDL_p& A, long resdeg)
// x = two element representation of prime ideal A
// resdeg = residual degree of A (i.e., norm of A = p^resdeg)
{
    long i;
    IDL1_p a;
    x.a = zz_p::modulus();
    power(x.N, x.a, resdeg);;
    conv(a, A, x.N);
    x.SetLength(IDL::degree());
    for(i=0; i<a.length(); i++) conv(x[i], a[i]);
}

void conv(IDL1& x, const IDL1_p& a)
// x = principal ideal genrated by a
// a = generator in integral basis representation
{
    long i;
    x.SetLength(IDL::degree());
    for(i=0; i<a.length(); i++) conv(x[i], a[i]);
    x.SetNorm();
}

void add(IDL_p& X, const IDL_p& A, const IDL_p& B)
// X = A+B; &X==&A is allowed
{
    long i,n(IDL::degree()),l(A.NumRows()),m(B.NumRows());
    mat_zz_p C(A);
    C.SetDims(l+m,n);
    for(i=0; i<m; i++) C[l+i] = B[i];
    image(X,C);
}

void add(IDL_p& X, const IDL_p& A, const IDL1_p& b)
// X = A+b; &X==&A is allowed
{
    IDL_p B;
    conv(B,b);
    add(X,A,B);
}

static void mul(vec_zz_p& x, const vec_zz_p& a, const vec_zz_p& b)
// x = a*b; assume &x!=&a, &x!=&b, and x=(0,0,...,0)
{
    long i,j;
    zz_p u;
    vec_zz_p v;
    for(i=0; i<a.length(); i++) {
        for(j=0; j<b.length(); j++) {
            mul(u, a[i], b[j]);
            mul(v, u, IDL_p::M[i][j]);
            x += v;
        }
    }
}

void mul(IDL_p& X, const IDL_p& A, const IDL_p& B)
// X = A*B; &X==&A is allowed
// reference: Cohen, algorithm 6.2.5
{
    long i,j,k,n(IDL::degree());
    long l(A.NumRows()), m(B.NumRows());
    mat_zz_p C;
    C.SetDims(l*m,n);
    for(i=k=0; i<l; i++)
        for(j=0; j<m; j++, k++)
            mul(C[k],A[i],B[j]);
    image(X,C);
}

void mul(IDL_p& X, const IDL_p& A, const IDL1_p& B)
// X = A*B; &X==&A is allowed
{
    long i,n(IDL::degree()),m(A.NumRows());
    mat_zz_p C;
    C.SetDims(m,n);
    for(i=0; i<m; i++) mul(C[i],A[i],B);
    image(X,C);
}

void sqr(IDL_p& X, const IDL_p& A)
// X = A*A; &X==&A is allowed
{
    long i,j,k,n(IDL::degree()),m(A.NumRows());
    mat_zz_p C;
    C.SetDims(m*(m+1)/2,n);
    for(i=k=0; i<m; i++)
        for(j=0; j<=i; j++, k++)
            mul(C[k],A[i],A[j]);
    image(X,C);
}

void div(IDL_p& X, const IDL_p& A, const IDL_p& B)
// X = A/B
// reference: Cohen, algorithm 6.2.7
{
    long I(A.NumRows()),J(B.NumRows()),K(J-I);
    long i,j,k,l,n(IDL::degree()),L(n*K);
    vec_zz_p a;
    mat_zz_p C,D;
    SuplBase(C,A,B);
    D.SetDims(L,n);
    for(i=l=0; i<K; i++)
        for(j=0; j<n; j++, l++)
            for(k=0; k<n; k++) {
                mul(a, C[i][k], IDL_p::M[j][k]);
                D[l] += a;
            }
    C.SetDims(J,n);
    for(i=0; i<I; i++) C[K+i] = A[i];
    InvImage(C,C,D);
    D.SetDims(n,K*K);
    for(i=0; i<n; i++)
        for(j=i, l=0; j<L; j+=n)
            for(k=0; k<K; k++, l++)
                D[i][l] = C[j][k];
    kernel(X,D);
}

void radical(IDL_p& X)
// X = square-free product of all prime ideals above p
// reference: Cohen, algorithm 6.1.8 step 7
{
    long i,j,n(IDL::degree());
    long p(zz_p::modulus()),q(p);
    ZZ a;
    ZZX f;
    mat_ZZ A;
    A.SetDims(n,n);
    while(q<n) q*=p;
    for(i=0; i<n; i++) {
        PowerMod(f, IDL::w[i], q, IDL::T);
        for(j=0; j<=deg(f); j++) A[i][j] = f[j];
    }
    power(a, IDL::d, q);
    A *= IDL::W1;
    a *= IDL::d1;
    for(i=0; i<n; i++)
        for(j=0; j<n; j++) A[i][j] /= a;
    conv(X,A);
    kernel(X,X);
}

long valuation(const IDL& A, const IDL_p& B)
// number of times that B divides A
// reference: Cohen, algorithm 4.8.17
{
    long i,j,k,l,m,n(IDL::degree()),r(B.NumRows());
    long p(zz_p::modulus());
    if(!divide(A.norm(), p)) return 0;
    mat_zz_p V;
    vec_zz_p v;
    IDL C(A);
    IDL1 a;
    V.SetDims(n,n*r);
    for(i=0; i<n; i++)
        for(j=0; j<n; j++)
            for(k=m=0; k<r; k++) {
                mul(v, IDL_p::M[i][j], B[k][j]);
                for(l=0; l<n; l++, m++)
                    V[i][m] += v[l];
            }
    kernel(V,V);
    conv(a,V[0]);
    for(k=0;; k++) {
        C *= a;
        for(i=n-1; i>=0; i--) {
            for(j=i; j>=0; j--)
                if(!divide(C[i][j], C[i][j], p))
                    return k;
            C.N /= p;
        }
    }
}

void conv(IDL1_p& x, const IDL_p& A, const ZZ& norm)
// convert prime ideal from matrix A to generator x
// norm = norm of A
// reference: Cohen, algorithm 4.7.10
{
    long i,n(IDL::degree()),m(A.NumRows());
    long r,s,p(zz_p::modulus());
    ZZ a,b,q;
    ZZX g;
    vec_zz_p c;
    vec_ZZ v;
    power(b, IDL::d, n);
    b *= norm;
    mul(q, p, IDL::d);
    c.SetLength(m);
    for(r=1; r<p; r++) {
        s = (p>2 ? -r:0);
        for(i=0; i<m; i++) c[i] = r;
        do {
            mul(x,c,A);
            conv(v,x);
            conv(g, v*=IDL::W);
            NormMod(a,g,IDL::T);
            if(divide(a,a,b) && !divide(a,p))
                return;
            g += q;
            NormMod(a,g,IDL::T);
            if(divide(a,a,b) && !divide(a,p))
                return;
            for(i=m-1; c[i]==s; i--);
            c[i]--;
            for(i++; i<m; i++) c[i] = r;
        } while(!IsZero(c));
    }
    Error("conv IDL_p to IDL1_p failed");        
}