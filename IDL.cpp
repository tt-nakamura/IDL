// uses NTL
//   http://www.shoup.net/ntl
// reference:
//   H. Cohen, "A Course in Computational Algebraic Number theory"
//     sections 2.4.3, 4.7.1, 4.7.2

#include "IDL.h"
#include<NTL/pair.h>

mat_ZZ IDL::W;// integral base matrix
mat_ZZ IDL::W1;// W inverse (numerator)
ZZ IDL::d;// integral base denominator
ZZ IDL::d1;// W inverse (denominator)
ZZ IDL::D;// field discriminant
ZZX IDL::T;// generating polynomial
Vec<ZZX> IDL::w;// polynomial representation of W
Mat<vec_ZZ> IDL::M;// multiplication table of W

void round2(ZZ&, mat_ZZ&, ZZ&, const ZZX&);
void factor(Vec<Pair<ZZ, long> >&, const ZZ&);

void IDL::init(const ZZX& T1)
// set generating polynomial T=T1
{
    long i,j,k,n(deg(T1));
    ZZ a;
    ZZX f;
    round2(D,W,d,T=T1);
    inv(d1,W1,W);
    mul(a,d,d1);
    w.SetLength(n);
    M.SetDims(n,n);
    // make multiplication table
    for(i=0; i<n; i++) {
        w[i].SetLength(i+1);
        for(j=0; j<=i; j++) w[i][j] = W[i][j];
        for(j=0; j<=i; j++) {
            MulMod(f,w[i],w[j],T);
            VectorCopy(M[i][j], f.rep, n);
            M[i][j] *= W1;
            for(k=0; k<n; k++) M[i][j][k] /= a;
        }
        for(j=0; j<i; j++) M[j][i] = M[i][j];
    }
    W1 *= d;
}

void IDL::index(ZZ& x)
// x = |det(power bases)/det(integral bases)|
{
    long i,n(degree());
    power(x,d,n);
    for(i=0; i<n; i++) x /= W[i][i];
}

void IDL::divisors(Vec<long>& x)
// x = prime divisors of denominator of integral bases
{
    long i;
    Vec<Pair<ZZ, long> > f;
    factor(f,d);
    x.SetLength(f.length());
    for(i=0; i<f.length(); i++) conv(x[i], f[i].a);
}

void set(IDL& X, const ZZ& a)
// X = principal ideal generated by a
{
    diag(X, IDL::degree(), a);
    power(X.N, a, IDL::degree());
}

void conv(IDL1& x, const ZZX& f, const ZZ& d)
// x = principal ideal generated by f/d
{
    long i,n(IDL::degree());
    ZZ a;
    ZZX g;
    rem(g, f, IDL::T);
    VectorCopy(x, g.rep, n);
    x *= IDL::W1;
    mul(a, d, IDL::d1);
    for(i=0; i<n; i++)
        if(!divide(x[i], x[i], a))
            Error("f/d is not integral");
    NormMod(x.N, g, IDL::T);
    abs(x.N, x.N);
    power(a,d,n);
    x.N /= a;
}

void conv(IDL& X, const ZZX& f, const ZZ& d)
// X = principal ideal generated by f/d
{
    IDL1 A;
    conv(A,f,d);
    conv(X,A);
}

void conv(IDL& X, const ZZ& a, const ZZX& f, const ZZ& d)
// X = ideal generated by (a, f/d)
{
    IDL1 x;
    conv(x,f,d);
    set(X,a);
    X += x;
}

void conv(IDL2& x, const ZZ& a, const ZZX& f, const ZZ& d)
// x = ideal generated by (a, f/d)
{
    IDL X;
    conv(x,f,d);
    set(X,a);
    X += (IDL1)x;
    x.a = a;
    x.N = X.norm();
}

void IDL::SetNorm() {
    long i,n(IDL::degree());
    set(N);
    for(i=0; i<n; i++) N *= (*this)[i][i];
}

void IDL1::SetNorm() {
    ZZ a;
    ZZX f;
    mul(f.rep, *this, IDL::W);
    f.normalize();
    NormMod(N, f, IDL::T);
    abs(N,N);
    power(a, IDL::d, IDL::degree());
    N /= a;
}

void add(IDL& X, const IDL& A, const IDL& B)
// X = A+B; &X==&A is allowed
{
    if(IsZero(A)) { X=B; return; }
    if(IsZero(B)) { X=A; return; }
    long i,n(IDL::degree());
    mat_ZZ C(A);
    C.SetDims(n+n,n);
    for(i=0; i<n; i++) C[n+i] = B[i];
    GCD(X.N, A.norm(), B.norm());
    HNF(X, C, X.N);
    X.SetNorm();
}

void add(IDL& X, const IDL& A, const IDL1& b)
// X = A+b; &X==&A is allowed
{
    IDL B;
    conv(B,b);
    add(X,A,B);
}

static void mul(vec_ZZ& x, const vec_ZZ& a, const vec_ZZ& b)
// x = a*b; assume &x!=&a, &x!=&b, and x=(0,0,...,0)
{
    long i,j;
    ZZ u;
    vec_ZZ v;
    for(i=0; i<a.length(); i++) {
        for(j=0; j<b.length(); j++) {
            mul(u, a[i], b[j]);
            mul(v, u, IDL::M[i][j]);
            x += v;
        }
    }
}

void mul(IDL& X, const IDL& A, const IDL& B)
// X = A*B; &X==&A is allowed
{
    mul(X.N, A.norm(), B.norm());
    if(IsZero(X.N)) return;
    long i,j,k,n(IDL::degree());
    mat_ZZ C;
    C.SetDims(n*n,n);
    for(i=k=0; i<n; i++)
        for(j=0; j<n; j++, k++)
            mul(C[k],A[i],B[j]);
    HNF(X, C, X.N);
}

void mul(IDL& X, const IDL& A, const IDL1& B)
// X = A*B; &X==&B is allowed
{
    mul(X.N, A.norm(), B.norm());
    if(IsZero(X.N)) return;
    long i,n(IDL::degree());
    mat_ZZ C;
    C.SetDims(n,n);
    for(i=0; i<n; i++) mul(C[i],A[i],B);
    HNF(X, C, X.N);
}

void mul(IDL& X, const IDL& A, const IDL2& B)
// X = A*B; &X==&A is allowed
{
    mul(X.N, A.norm(), B.norm());
    if(IsZero(X.N)) return;
    long i,n(IDL::degree());
    mat_ZZ C;
    C.SetDims(n+n,n);
    for(i=0; i<n; i++) mul(C[i], A[i], B.a);
    for(i=0; i<n; i++) mul(C[n+i],A[i],B);
    HNF(X, C, X.N);
}

void sqr(IDL& X, const IDL& A)
// X = A*A; &X==&A is allowed
{
    sqr(X.N, A.norm());
    if(IsZero(X.N)) return;
    long i,j,k,n(IDL::degree());
    mat_ZZ C;
    C.SetDims(n*(n+1)/2,n);
    for(i=k=0; i<n; i++)
        for(j=0; j<=i; j++, k++)
            mul(C[k],A[i],A[j]);
    HNF(X, C, X.N);
}

void power(IDL& X, const IDL& A, const ZZ& n)
// X = A^n (n>=0); &X==&A is allowed
{
    if(&X==&A) { IDL B(A); power(X,B,n); return; }
    if(IsZero(n)) { set(X); return; }
    long i;
    X=A;
    for(i=NumBits(n)-2; i>=0; i--) {
        sqr(X,X);
        if(bit(n,i)) X*=A;
    }
}

void power(IDL& X, const IDL& A, long n)
// X = A^n (n>=0); &X==&A is allowed
{
    if(&X==&A) { IDL B(A); power(X,B,n); return; }
    if(n==0) { set(X); return; }
    long m(1L<<(NumBits(n)-1));
    X=A;
    for(m>>=1; m; m>>=1) {
        sqr(X,X);
        if(n&m) X*=A;
    }
}

std::ostream& operator<<(std::ostream& s, const IDL2& a)
// two element representation in power basis
{
    if(IsZero(a)) return s << "[]";
    vec_ZZ v;
    ZZX f;
    ZZ c;
    mul(v, a, IDL::W);
    conv(f,v);
    content(c,f);
    GCD(c, c, IDL::d);
    f /= c;
    div(c, IDL::d, c);
    s << '[' << a.a;
    if(!IsZero(f)) {
        s << ' ' << f;
        if(!IsOne(c)) s << '/' << c;
    }
    s << ']';
    return s;
}